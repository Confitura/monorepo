/* tslint:disable */
/* eslint-disable */
/**
 * Jelatyna API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AgendaEntry
 */
export interface AgendaEntry {
    /**
     * 
     * @type {string}
     * @memberof AgendaEntry
     */
    'id'?: string;
    /**
     * 
     * @type {TimeSlot}
     * @memberof AgendaEntry
     */
    'timeSlot': TimeSlot;
    /**
     * 
     * @type {Room}
     * @memberof AgendaEntry
     */
    'room'?: Room;
    /**
     * 
     * @type {string}
     * @memberof AgendaEntry
     */
    'label'?: string;
    /**
     * 
     * @type {Presentation}
     * @memberof AgendaEntry
     */
    'presentation'?: Presentation;
    /**
     * 
     * @type {number}
     * @memberof AgendaEntry
     */
    'timeSlotOrder'?: number;
    /**
     * 
     * @type {string}
     * @memberof AgendaEntry
     */
    'presentationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AgendaEntry
     */
    'roomId'?: string;
    /**
     * 
     * @type {Set<PublicUser>}
     * @memberof AgendaEntry
     */
    'speakers'?: Set<PublicUser>;
}
/**
 * 
 * @export
 * @interface AllegroContext
 */
export interface AllegroContext {
    /**
     * 
     * @type {string}
     * @memberof AllegroContext
     */
    'auctionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllegroContext
     */
    'auctionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllegroContext
     */
    'buyerLogin'?: string;
}
/**
 * 
 * @export
 * @interface AssignAgendaEntryRequest
 */
export interface AssignAgendaEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof AssignAgendaEntryRequest
     */
    'dayId': string;
    /**
     * 
     * @type {number}
     * @memberof AssignAgendaEntryRequest
     */
    'timeSlotIndex': number;
    /**
     * 
     * @type {string}
     * @memberof AssignAgendaEntryRequest
     */
    'roomId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AssignAgendaEntryRequest
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof AssignAgendaEntryRequest
     */
    'presentationId': string;
}
/**
 * 
 * @export
 * @interface Day
 */
export interface Day {
    /**
     * 
     * @type {string}
     * @memberof Day
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Day
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Day
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Day
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Day
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Day
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof Day
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof Day
     */
    'displayOrder': number;
}
/**
 * 
 * @export
 * @interface FullPresentation
 */
export interface FullPresentation {
    /**
     * 
     * @type {string}
     * @memberof FullPresentation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof FullPresentation
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof FullPresentation
     */
    'shortDescription': string;
    /**
     * 
     * @type {string}
     * @memberof FullPresentation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof FullPresentation
     */
    'level': string;
    /**
     * 
     * @type {string}
     * @memberof FullPresentation
     */
    'language': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof FullPresentation
     */
    'tags': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof FullPresentation
     */
    'isWorkshop': boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullPresentation
     */
    'isFree': boolean;
    /**
     * 
     * @type {number}
     * @memberof FullPresentation
     */
    'expectedPrice': number;
    /**
     * 
     * @type {number}
     * @memberof FullPresentation
     */
    'durationInMinutes': number;
    /**
     * 
     * @type {number}
     * @memberof FullPresentation
     */
    'maxGroupSize': number;
    /**
     * 
     * @type {string}
     * @memberof FullPresentation
     */
    'status': string;
    /**
     * 
     * @type {Array<Speaker>}
     * @memberof FullPresentation
     */
    'speakers': Array<Speaker>;
}
/**
 * 
 * @export
 * @interface FullUser
 */
export interface FullUser {
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'github'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'www'?: string;
    /**
     * 
     * @type {string}
     * @memberof FullUser
     */
    'photo'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'isAdmin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'isVolunteer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'isSpeaker'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'privacyPolicyAccepted'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'isParticipant'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof FullUser
     */
    'hasAcceptedPresentation'?: boolean;
}
/**
 * 
 * @export
 * @interface GenerateVouchersRequest
 */
export interface GenerateVouchersRequest {
    /**
     * 
     * @type {string}
     * @memberof GenerateVouchersRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerateVouchersRequest
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof GenerateVouchersRequest
     */
    'sponsorVouchers'?: number;
    /**
     * 
     * @type {number}
     * @memberof GenerateVouchersRequest
     */
    'participantVouchers'?: number;
}
/**
 * 
 * @export
 * @interface InlineAgendaEntry
 */
export interface InlineAgendaEntry {
    /**
     * 
     * @type {string}
     * @memberof InlineAgendaEntry
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InlineAgendaEntry
     */
    'dayId': string;
    /**
     * 
     * @type {number}
     * @memberof InlineAgendaEntry
     */
    'timeSlotIndex': number;
    /**
     * 
     * @type {string}
     * @memberof InlineAgendaEntry
     */
    'roomId'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineAgendaEntry
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof InlineAgendaEntry
     */
    'presentationId'?: string;
}
/**
 * 
 * @export
 * @interface InlineDay
 */
export interface InlineDay {
    /**
     * 
     * @type {string}
     * @memberof InlineDay
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InlineDay
     */
    'date': string;
    /**
     * 
     * @type {string}
     * @memberof InlineDay
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof InlineDay
     */
    'displayOrder': number;
}
/**
 * 
 * @export
 * @interface InlinePresentation
 */
export interface InlinePresentation {
    /**
     * 
     * @type {string}
     * @memberof InlinePresentation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InlinePresentation
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof InlinePresentation
     */
    'shortDescription': string;
    /**
     * 
     * @type {string}
     * @memberof InlinePresentation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof InlinePresentation
     */
    'level': string;
    /**
     * 
     * @type {string}
     * @memberof InlinePresentation
     */
    'language': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlinePresentation
     */
    'tags': Array<string>;
}
/**
 * 
 * @export
 * @interface InlineRoom
 */
export interface InlineRoom {
    /**
     * 
     * @type {string}
     * @memberof InlineRoom
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InlineRoom
     */
    'label': string;
    /**
     * 
     * @type {number}
     * @memberof InlineRoom
     */
    'displayOrder': number;
}
/**
 * 
 * @export
 * @interface InlineTimeSlot
 */
export interface InlineTimeSlot {
    /**
     * Day identifier
     * @type {string}
     * @memberof InlineTimeSlot
     */
    'dayId': string;
    /**
     * 
     * @type {number}
     * @memberof InlineTimeSlot
     */
    'displayOrder': number;
    /**
     * 
     * @type {string}
     * @memberof InlineTimeSlot
     */
    'label': string;
    /**
     * 
     * @type {string}
     * @memberof InlineTimeSlot
     */
    'start': string;
    /**
     * 
     * @type {string}
     * @memberof InlineTimeSlot
     */
    'end': string;
}
/**
 * 
 * @export
 * @interface InlineVote
 */
export interface InlineVote {
    /**
     * 
     * @type {string}
     * @memberof InlineVote
     */
    'id': string;
    /**
     * 
     * @type {number}
     * @memberof InlineVote
     */
    'order': number;
    /**
     * 
     * @type {InlineVotePresentation}
     * @memberof InlineVote
     */
    'presentation': InlineVotePresentation;
    /**
     * 
     * @type {number}
     * @memberof InlineVote
     */
    'rate': number;
}
/**
 * 
 * @export
 * @interface InlineVotePresentation
 */
export interface InlineVotePresentation {
    /**
     * 
     * @type {string}
     * @memberof InlineVotePresentation
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InlineVotePresentation
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof InlineVotePresentation
     */
    'longDescription': string;
    /**
     * 
     * @type {string}
     * @memberof InlineVotePresentation
     */
    'shortDescription': string;
    /**
     * 
     * @type {Array<InlineVoteSpeaker>}
     * @memberof InlineVotePresentation
     */
    'speakers': Array<InlineVoteSpeaker>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineVotePresentation
     */
    'workshop': boolean;
}
/**
 * 
 * @export
 * @interface InlineVoteSpeaker
 */
export interface InlineVoteSpeaker {
    /**
     * 
     * @type {string}
     * @memberof InlineVoteSpeaker
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InlineVoteSpeaker
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof InlineVoteSpeaker
     */
    'bio': string;
    /**
     * 
     * @type {string}
     * @memberof InlineVoteSpeaker
     */
    'photo': string;
}
/**
 * 
 * @export
 * @interface InlineWorkshop
 */
export interface InlineWorkshop {
    /**
     * 
     * @type {string}
     * @memberof InlineWorkshop
     */
    'id': string;
    /**
     * 
     * @type {string}
     * @memberof InlineWorkshop
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof InlineWorkshop
     */
    'shortDescription': string;
    /**
     * 
     * @type {string}
     * @memberof InlineWorkshop
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof InlineWorkshop
     */
    'level': string;
    /**
     * 
     * @type {string}
     * @memberof InlineWorkshop
     */
    'language': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof InlineWorkshop
     */
    'tags': Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof InlineWorkshop
     */
    'isFree': boolean;
    /**
     * 
     * @type {number}
     * @memberof InlineWorkshop
     */
    'expectedPrice': number;
    /**
     * 
     * @type {number}
     * @memberof InlineWorkshop
     */
    'durationInMinutes': number;
    /**
     * 
     * @type {number}
     * @memberof InlineWorkshop
     */
    'maxGroupSize': number;
}
/**
 * 
 * @export
 * @interface Like
 */
export interface Like {
    /**
     * 
     * @type {string}
     * @memberof Like
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Like
     */
    'token': string;
    /**
     * 
     * @type {Presentation}
     * @memberof Like
     */
    'presentation'?: Presentation;
}
/**
 * 
 * @export
 * @interface LikeResponse
 */
export interface LikeResponse {
    /**
     * 
     * @type {string}
     * @memberof LikeResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeResponse
     */
    'presentationId'?: string;
}
/**
 * 
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'minute'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'second'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'nano'?: number;
}
/**
 * 
 * @export
 * @interface MessageInfo
 */
export interface MessageInfo {
    /**
     * 
     * @type {string}
     * @memberof MessageInfo
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageInfo
     */
    'ticket'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MessageInfo
     */
    'variables'?: { [key: string]: string; };
    /**
     * 
     * @type {MessageInfo}
     * @memberof MessageInfo
     */
    'name'?: MessageInfo;
    /**
     * 
     * @type {MessageInfo}
     * @memberof MessageInfo
     */
    'token'?: MessageInfo;
}
/**
 * 
 * @export
 * @interface NewsletterStat
 */
export interface NewsletterStat {
    /**
     * 
     * @type {number}
     * @memberof NewsletterStat
     */
    'subscribersCount'?: number;
}
/**
 * 
 * @export
 * @interface PageContent
 */
export interface PageContent {
    /**
     * 
     * @type {string}
     * @memberof PageContent
     */
    'content'?: string;
}
/**
 * 
 * @export
 * @interface ParticipationData
 */
export interface ParticipationData {
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'id'?: string;
    /**
     * 
     * @type {Voucher}
     * @memberof ParticipationData
     */
    'voucher'?: Voucher;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParticipationData
     */
    'privacyPolicyAccepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'info'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'arrivalDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'registrationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'registeredBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'ticketSendDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'surveySendDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'fullName'?: string;
}
/**
 * 
 * @export
 * @interface Presentation
 */
export interface Presentation {
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'shortDescription': string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'level': string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'language': string;
    /**
     * 
     * @type {Set<Tag>}
     * @memberof Presentation
     */
    'tags'?: Set<Tag>;
    /**
     * 
     * @type {Set<User>}
     * @memberof Presentation
     */
    'speakers': Set<User>;
    /**
     * 
     * @type {Set<Rate>}
     * @memberof Presentation
     */
    'ratings'?: Set<Rate>;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'status'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Presentation
     */
    'workshop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Presentation
     */
    'isFree'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof Presentation
     */
    'expectedPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof Presentation
     */
    'durationInMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof Presentation
     */
    'maxGroupSize'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof Presentation
     */
    'new'?: boolean;
    /**
     * 
     * @type {Presentation}
     * @memberof Presentation
     */
    'speaker'?: Presentation;
    /**
     * 
     * @type {boolean}
     * @memberof Presentation
     */
    'accepted'?: boolean;
}
/**
 * 
 * @export
 * @interface PresentationRequest
 */
export interface PresentationRequest {
    /**
     * 
     * @type {string}
     * @memberof PresentationRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PresentationRequest
     */
    'shortDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof PresentationRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof PresentationRequest
     */
    'level'?: string;
    /**
     * 
     * @type {string}
     * @memberof PresentationRequest
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof PresentationRequest
     */
    'tags'?: Array<string>;
}
/**
 * 
 * @export
 * @interface PresentationStats
 */
export interface PresentationStats {
    /**
     * 
     * @type {string}
     * @memberof PresentationStats
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof PresentationStats
     */
    'presentationId'?: string;
    /**
     * 
     * @type {number}
     * @memberof PresentationStats
     */
    'positiveVotes'?: number;
    /**
     * 
     * @type {number}
     * @memberof PresentationStats
     */
    'negativeVotes'?: number;
    /**
     * 
     * @type {number}
     * @memberof PresentationStats
     */
    'totalVotes'?: number;
    /**
     * 
     * @type {number}
     * @memberof PresentationStats
     */
    'rateOfPositive'?: number;
    /**
     * 
     * @type {number}
     * @memberof PresentationStats
     */
    'rateOfNegative'?: number;
}
/**
 * 
 * @export
 * @interface PublicUser
 */
export interface PublicUser {
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'github'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'www'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'photo'?: string;
}
/**
 * 
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'value'?: RateValueEnum;
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'comment'?: string;
    /**
     * 
     * @type {Presentation}
     * @memberof Rate
     */
    'presentation'?: Presentation;
}

export const RateValueEnum = {
    Awesome: 'AWESOME',
    Great: 'GREAT',
    ItWasFine: 'IT_WAS_FINE',
    Bad: 'BAD',
    Terrible: 'TERRIBLE'
} as const;

export type RateValueEnum = typeof RateValueEnum[keyof typeof RateValueEnum];

/**
 * 
 * @export
 * @interface RateRequest
 */
export interface RateRequest {
    /**
     * 
     * @type {string}
     * @memberof RateRequest
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof RateRequest
     */
    'reviewerToken'?: string;
    /**
     * 
     * @type {number}
     * @memberof RateRequest
     */
    'value'?: number;
    /**
     * 
     * @type {string}
     * @memberof RateRequest
     */
    'comment'?: string;
}
/**
 * 
 * @export
 * @interface RegistrationError
 */
export interface RegistrationError {
    /**
     * 
     * @type {string}
     * @memberof RegistrationError
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationError
     */
    'additionalInfo'?: string;
}
/**
 * 
 * @export
 * @interface Room
 */
export interface Room {
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'label'?: string;
    /**
     * 
     * @type {number}
     * @memberof Room
     */
    'displayOrder': number;
    /**
     * 
     * @type {Day}
     * @memberof Room
     */
    'day': Day;
}
/**
 * 
 * @export
 * @interface SendMailsRequest
 */
export interface SendMailsRequest {
    /**
     * 
     * @type {string}
     * @memberof SendMailsRequest
     */
    'template'?: string;
    /**
     * 
     * @type {Array<MessageInfo>}
     * @memberof SendMailsRequest
     */
    'messageInfoList'?: Array<MessageInfo>;
}
/**
 * 
 * @export
 * @interface Speaker
 */
export interface Speaker {
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Speaker
     */
    'photo'?: string;
}
/**
 * 
 * @export
 * @interface SubmittedStats
 */
export interface SubmittedStats {
    /**
     * 
     * @type {number}
     * @memberof SubmittedStats
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubmittedStats
     */
    'presentations'?: number;
    /**
     * 
     * @type {number}
     * @memberof SubmittedStats
     */
    'workshops'?: number;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TimeSlot
 */
export interface TimeSlot {
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {TimeSlotId}
     * @memberof TimeSlot
     */
    'id': TimeSlotId;
    /**
     * 
     * @type {LocalTime}
     * @memberof TimeSlot
     */
    'start'?: LocalTime;
    /**
     * 
     * @type {LocalTime}
     * @memberof TimeSlot
     */
    'end'?: LocalTime;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSlot
     */
    'forAllRooms'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'label'?: string;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    'displayOrder'?: number;
}
/**
 * 
 * @export
 * @interface TimeSlotId
 */
export interface TimeSlotId {
    /**
     * 
     * @type {string}
     * @memberof TimeSlotId
     */
    'dayId': string;
    /**
     * 
     * @type {number}
     * @memberof TimeSlotId
     */
    'displayOrder': number;
}
/**
 * 
 * @export
 * @interface Tweet
 */
export interface Tweet {
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'twitterHandle'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface UpdateAgendaEntryRequest
 */
export interface UpdateAgendaEntryRequest {
    /**
     * 
     * @type {string}
     * @memberof UpdateAgendaEntryRequest
     */
    'label'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAgendaEntryRequest
     */
    'presentationId'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpdateAgendaEntryRequest
     */
    'roomId'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'github'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'www'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'socialId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'privacyPolicyAccepted'?: boolean;
    /**
     * 
     * @type {Set<AgendaEntry>}
     * @memberof User
     */
    'personalAgenda'?: Set<AgendaEntry>;
    /**
     * 
     * @type {ParticipationData}
     * @memberof User
     */
    'participationData'?: ParticipationData;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'participant'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'admin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'volunteer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'speaker'?: boolean;
}
/**
 * 
 * @export
 * @interface UsersStats
 */
export interface UsersStats {
    /**
     * 
     * @type {number}
     * @memberof UsersStats
     */
    'total'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersStats
     */
    'admins'?: number;
    /**
     * 
     * @type {number}
     * @memberof UsersStats
     */
    'volunteers'?: number;
}
/**
 * 
 * @export
 * @interface VoteRequest
 */
export interface VoteRequest {
    /**
     * 
     * @type {string}
     * @memberof VoteRequest
     */
    'id'?: string;
    /**
     * 
     * @type {number}
     * @memberof VoteRequest
     */
    'rate'?: number;
}
/**
 * 
 * @export
 * @interface Voucher
 */
export interface Voucher {
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'originalBuyer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'comment'?: string;
    /**
     * 
     * @type {AllegroContext}
     * @memberof Voucher
     */
    'allegro'?: AllegroContext;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'ticketSendDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'type'?: VoucherTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Voucher
     */
    'emailSent'?: boolean;
}

export const VoucherTypeEnum = {
    Participant: 'PARTICIPANT',
    Speaker: 'SPEAKER',
    Sponsor: 'SPONSOR'
} as const;

export type VoucherTypeEnum = typeof VoucherTypeEnum[keyof typeof VoucherTypeEnum];

/**
 * 
 * @export
 * @interface WorkshopRequest
 */
export interface WorkshopRequest {
    /**
     * 
     * @type {string}
     * @memberof WorkshopRequest
     */
    'title'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopRequest
     */
    'shortDescription'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopRequest
     */
    'description'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopRequest
     */
    'level'?: string;
    /**
     * 
     * @type {string}
     * @memberof WorkshopRequest
     */
    'language'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof WorkshopRequest
     */
    'tags'?: Array<string>;
    /**
     * 
     * @type {boolean}
     * @memberof WorkshopRequest
     */
    'isFree'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof WorkshopRequest
     */
    'expectedPrice'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkshopRequest
     */
    'durationInMinutes'?: number;
    /**
     * 
     * @type {number}
     * @memberof WorkshopRequest
     */
    'maxGroupSize'?: number;
}

/**
 * AdminPresentationControllerApi - axios parameter creator
 * @export
 */
export const AdminPresentationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accept: async (presentationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('accept', 'presentationId', presentationId)
            const localVarPath = `/presentations/{presentationId}/accept`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject: async (presentationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('reject', 'presentationId', presentationId)
            const localVarPath = `/presentations/{presentationId}/reject`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTags: async (body: object, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'body' is not null or undefined
            assertParamExists('saveTags', 'body', body)
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(body, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AdminPresentationControllerApi - functional programming interface
 * @export
 */
export const AdminPresentationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AdminPresentationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async accept(presentationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.accept(presentationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminPresentationControllerApi.accept']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async reject(presentationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.reject(presentationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminPresentationControllerApi.reject']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveTags(body: object, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveTags(body, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AdminPresentationControllerApi.saveTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AdminPresentationControllerApi - factory interface
 * @export
 */
export const AdminPresentationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AdminPresentationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accept(presentationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.accept(presentationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reject(presentationId: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.reject(presentationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {object} body 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveTags(body: object, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.saveTags(body, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AdminPresentationControllerApi - object-oriented interface
 * @export
 * @class AdminPresentationControllerApi
 * @extends {BaseAPI}
 */
export class AdminPresentationControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} presentationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminPresentationControllerApi
     */
    public accept(presentationId: string, options?: RawAxiosRequestConfig) {
        return AdminPresentationControllerApiFp(this.configuration).accept(presentationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} presentationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminPresentationControllerApi
     */
    public reject(presentationId: string, options?: RawAxiosRequestConfig) {
        return AdminPresentationControllerApiFp(this.configuration).reject(presentationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {object} body 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AdminPresentationControllerApi
     */
    public saveTags(body: object, options?: RawAxiosRequestConfig) {
        return AdminPresentationControllerApiFp(this.configuration).saveTags(body, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AgendaControllerApi - axios parameter creator
 * @export
 */
export const AgendaControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgendaEntry: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteAgendaEntry', 'id', id)
            const localVarPath = `/agenda/entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgendaEntriesByDay: async (dayId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dayId' is not null or undefined
            assertParamExists('getAgendaEntriesByDay', 'dayId', dayId)
            const localVarPath = `/agenda/{dayId}/entries`
                .replace(`{${"dayId"}}`, encodeURIComponent(String(dayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgendaEntryById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAgendaEntryById', 'id', id)
            const localVarPath = `/agenda/entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDays1: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/agenda/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRooms1: async (dayId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dayId' is not null or undefined
            assertParamExists('getAllRooms1', 'dayId', dayId)
            const localVarPath = `/agenda/{dayId}/rooms`
                .replace(`{${"dayId"}}`, encodeURIComponent(String(dayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTimeSlots: async (dayId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'dayId' is not null or undefined
            assertParamExists('getAllTimeSlots', 'dayId', dayId)
            const localVarPath = `/agenda/{dayId}/time-slots`
                .replace(`{${"dayId"}}`, encodeURIComponent(String(dayId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {AssignAgendaEntryRequest} assignAgendaEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAgendaEntry: async (assignAgendaEntryRequest: AssignAgendaEntryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'assignAgendaEntryRequest' is not null or undefined
            assertParamExists('saveAgendaEntry', 'assignAgendaEntryRequest', assignAgendaEntryRequest)
            const localVarPath = `/agenda/entries`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(assignAgendaEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAgendaEntryRequest} updateAgendaEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgendaEntry: async (id: string, updateAgendaEntryRequest: UpdateAgendaEntryRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updateAgendaEntry', 'id', id)
            // verify required parameter 'updateAgendaEntryRequest' is not null or undefined
            assertParamExists('updateAgendaEntry', 'updateAgendaEntryRequest', updateAgendaEntryRequest)
            const localVarPath = `/agenda/entries/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(updateAgendaEntryRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AgendaControllerApi - functional programming interface
 * @export
 */
export const AgendaControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AgendaControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteAgendaEntry(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteAgendaEntry(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgendaControllerApi.deleteAgendaEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgendaEntriesByDay(dayId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineAgendaEntry>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgendaEntriesByDay(dayId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgendaControllerApi.getAgendaEntriesByDay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAgendaEntryById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineAgendaEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAgendaEntryById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgendaControllerApi.getAgendaEntryById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDays1(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineDay>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDays1(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgendaControllerApi.getAllDays1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRooms1(dayId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineRoom>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRooms1(dayId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgendaControllerApi.getAllRooms1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTimeSlots(dayId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineTimeSlot>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTimeSlots(dayId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgendaControllerApi.getAllTimeSlots']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {AssignAgendaEntryRequest} assignAgendaEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveAgendaEntry(assignAgendaEntryRequest: AssignAgendaEntryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineAgendaEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveAgendaEntry(assignAgendaEntryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgendaControllerApi.saveAgendaEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAgendaEntryRequest} updateAgendaEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateAgendaEntry(id: string, updateAgendaEntryRequest: UpdateAgendaEntryRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineAgendaEntry>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateAgendaEntry(id, updateAgendaEntryRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AgendaControllerApi.updateAgendaEntry']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AgendaControllerApi - factory interface
 * @export
 */
export const AgendaControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AgendaControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAgendaEntry(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteAgendaEntry(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgendaEntriesByDay(dayId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<InlineAgendaEntry>> {
            return localVarFp.getAgendaEntriesByDay(dayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAgendaEntryById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineAgendaEntry> {
            return localVarFp.getAgendaEntryById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDays1(options?: RawAxiosRequestConfig): AxiosPromise<Array<InlineDay>> {
            return localVarFp.getAllDays1(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRooms1(dayId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<InlineRoom>> {
            return localVarFp.getAllRooms1(dayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} dayId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTimeSlots(dayId: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<InlineTimeSlot>> {
            return localVarFp.getAllTimeSlots(dayId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {AssignAgendaEntryRequest} assignAgendaEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveAgendaEntry(assignAgendaEntryRequest: AssignAgendaEntryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InlineAgendaEntry> {
            return localVarFp.saveAgendaEntry(assignAgendaEntryRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {UpdateAgendaEntryRequest} updateAgendaEntryRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAgendaEntry(id: string, updateAgendaEntryRequest: UpdateAgendaEntryRequest, options?: RawAxiosRequestConfig): AxiosPromise<InlineAgendaEntry> {
            return localVarFp.updateAgendaEntry(id, updateAgendaEntryRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AgendaControllerApi - object-oriented interface
 * @export
 * @class AgendaControllerApi
 * @extends {BaseAPI}
 */
export class AgendaControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendaControllerApi
     */
    public deleteAgendaEntry(id: string, options?: RawAxiosRequestConfig) {
        return AgendaControllerApiFp(this.configuration).deleteAgendaEntry(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dayId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendaControllerApi
     */
    public getAgendaEntriesByDay(dayId: string, options?: RawAxiosRequestConfig) {
        return AgendaControllerApiFp(this.configuration).getAgendaEntriesByDay(dayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendaControllerApi
     */
    public getAgendaEntryById(id: string, options?: RawAxiosRequestConfig) {
        return AgendaControllerApiFp(this.configuration).getAgendaEntryById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendaControllerApi
     */
    public getAllDays1(options?: RawAxiosRequestConfig) {
        return AgendaControllerApiFp(this.configuration).getAllDays1(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dayId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendaControllerApi
     */
    public getAllRooms1(dayId: string, options?: RawAxiosRequestConfig) {
        return AgendaControllerApiFp(this.configuration).getAllRooms1(dayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} dayId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendaControllerApi
     */
    public getAllTimeSlots(dayId: string, options?: RawAxiosRequestConfig) {
        return AgendaControllerApiFp(this.configuration).getAllTimeSlots(dayId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {AssignAgendaEntryRequest} assignAgendaEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendaControllerApi
     */
    public saveAgendaEntry(assignAgendaEntryRequest: AssignAgendaEntryRequest, options?: RawAxiosRequestConfig) {
        return AgendaControllerApiFp(this.configuration).saveAgendaEntry(assignAgendaEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {UpdateAgendaEntryRequest} updateAgendaEntryRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AgendaControllerApi
     */
    public updateAgendaEntry(id: string, updateAgendaEntryRequest: UpdateAgendaEntryRequest, options?: RawAxiosRequestConfig) {
        return AgendaControllerApiFp(this.configuration).updateAgendaEntry(id, updateAgendaEntryRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * AllegroImportControllerApi - axios parameter creator
 * @export
 */
export const AllegroImportControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allegro/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (code: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('callback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('callback', 'state', state)
            const localVarPath = `/allegro/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doImport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allegro/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allegro/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFromAllegro: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allegro/report/ready-to-send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllegroImportControllerApi - functional programming interface
 * @export
 */
export const AllegroImportControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllegroImportControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.authorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(code: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.callback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doImport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doImport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.doImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFromAllegro(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFromAllegro(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.importFromAllegro']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AllegroImportControllerApi - factory interface
 * @export
 */
export const AllegroImportControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllegroImportControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authorize(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(code: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.callback(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doImport(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.doImport(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFromAllegro(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.importFromAllegro(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllegroImportControllerApi - object-oriented interface
 * @export
 * @class AllegroImportControllerApi
 * @extends {BaseAPI}
 */
export class AllegroImportControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public authorize(options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).authorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public callback(code: string, state: string, options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).callback(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public doImport(options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).doImport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public importFromAllegro(options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).importFromAllegro(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardControllerApi - axios parameter creator
 * @export
 */
export const DashboardControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrivals: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/arrivals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMealStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/meal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTShirtSizes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/tshirts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/vouchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterStat: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/newsletter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/registrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/submissions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardControllerApi - functional programming interface
 * @export
 */
export const DashboardControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arrivals(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arrivals(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.arrivals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMealStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMealStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.getMealStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistrationStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegistrationStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.getRegistrationStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTShirtSizes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTShirtSizes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.getTShirtSizes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVoucherStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoucherStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.getVoucherStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async newsletterStat(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<NewsletterStat>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.newsletterStat(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.newsletterStat']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registrations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registrations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.registrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async submissionStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubmittedStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.submissionStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.submissionStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async usersStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<UsersStats>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.usersStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.usersStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardControllerApi - factory interface
 * @export
 */
export const DashboardControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrivals(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.arrivals(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMealStats(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getMealStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStats(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getRegistrationStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTShirtSizes(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getTShirtSizes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherStats(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getVoucherStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        newsletterStat(options?: RawAxiosRequestConfig): AxiosPromise<NewsletterStat> {
            return localVarFp.newsletterStat(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrations(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.registrations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        submissionStats(options?: RawAxiosRequestConfig): AxiosPromise<SubmittedStats> {
            return localVarFp.submissionStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        usersStats(options?: RawAxiosRequestConfig): AxiosPromise<UsersStats> {
            return localVarFp.usersStats(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardControllerApi - object-oriented interface
 * @export
 * @class DashboardControllerApi
 * @extends {BaseAPI}
 */
export class DashboardControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public arrivals(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).arrivals(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getMealStats(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).getMealStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getRegistrationStats(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).getRegistrationStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getTShirtSizes(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).getTShirtSizes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getVoucherStats(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).getVoucherStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public newsletterStat(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).newsletterStat(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public registrations(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).registrations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public submissionStats(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).submissionStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public usersStats(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).usersStats(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DayControllerApi - axios parameter creator
 * @export
 */
export const DayControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDay: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteDay', 'id', id)
            const localVarPath = `/days/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDays: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDayById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getDayById', 'id', id)
            const localVarPath = `/days/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Day} day 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDay: async (day: Day, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'day' is not null or undefined
            assertParamExists('saveDay', 'day', day)
            const localVarPath = `/days`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(day, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DayControllerApi - functional programming interface
 * @export
 */
export const DayControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DayControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteDay(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteDay(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DayControllerApi.deleteDay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllDays(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineDay>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllDays(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DayControllerApi.getAllDays']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getDayById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineDay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getDayById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DayControllerApi.getDayById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Day} day 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveDay(day: Day, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineDay>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveDay(day, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DayControllerApi.saveDay']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DayControllerApi - factory interface
 * @export
 */
export const DayControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DayControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDay(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteDay(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllDays(options?: RawAxiosRequestConfig): AxiosPromise<Array<InlineDay>> {
            return localVarFp.getAllDays(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDayById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineDay> {
            return localVarFp.getDayById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Day} day 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveDay(day: Day, options?: RawAxiosRequestConfig): AxiosPromise<InlineDay> {
            return localVarFp.saveDay(day, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DayControllerApi - object-oriented interface
 * @export
 * @class DayControllerApi
 * @extends {BaseAPI}
 */
export class DayControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayControllerApi
     */
    public deleteDay(id: string, options?: RawAxiosRequestConfig) {
        return DayControllerApiFp(this.configuration).deleteDay(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayControllerApi
     */
    public getAllDays(options?: RawAxiosRequestConfig) {
        return DayControllerApiFp(this.configuration).getAllDays(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayControllerApi
     */
    public getDayById(id: string, options?: RawAxiosRequestConfig) {
        return DayControllerApiFp(this.configuration).getDayById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Day} day 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DayControllerApi
     */
    public saveDay(day: Day, options?: RawAxiosRequestConfig) {
        return DayControllerApiFp(this.configuration).saveDay(day, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FakeOAuth2LoginControllerApi - axios parameter creator
 * @export
 */
export const FakeOAuth2LoginControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLoginWithGitHub: async (provider: string, redirectUri: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('doLoginWithGitHub', 'provider', provider)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('doLoginWithGitHub', 'redirectUri', redirectUri)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('doLoginWithGitHub', 'state', state)
            const localVarPath = `/login/{provider}/callback`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToGitHubLogin: async (provider: string, redirectUri: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('redirectToGitHubLogin', 'provider', provider)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('redirectToGitHubLogin', 'redirectUri', redirectUri)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('redirectToGitHubLogin', 'state', state)
            const localVarPath = `/login/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FakeOAuth2LoginControllerApi - functional programming interface
 * @export
 */
export const FakeOAuth2LoginControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FakeOAuth2LoginControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doLoginWithGitHub(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doLoginWithGitHub(provider, redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FakeOAuth2LoginControllerApi.doLoginWithGitHub']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectToGitHubLogin(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectToGitHubLogin(provider, redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FakeOAuth2LoginControllerApi.redirectToGitHubLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FakeOAuth2LoginControllerApi - factory interface
 * @export
 */
export const FakeOAuth2LoginControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FakeOAuth2LoginControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLoginWithGitHub(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.doLoginWithGitHub(provider, redirectUri, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToGitHubLogin(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.redirectToGitHubLogin(provider, redirectUri, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FakeOAuth2LoginControllerApi - object-oriented interface
 * @export
 * @class FakeOAuth2LoginControllerApi
 * @extends {BaseAPI}
 */
export class FakeOAuth2LoginControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} provider 
     * @param {string} redirectUri 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeOAuth2LoginControllerApi
     */
    public doLoginWithGitHub(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig) {
        return FakeOAuth2LoginControllerApiFp(this.configuration).doLoginWithGitHub(provider, redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} provider 
     * @param {string} redirectUri 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeOAuth2LoginControllerApi
     */
    public redirectToGitHubLogin(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig) {
        return FakeOAuth2LoginControllerApiFp(this.configuration).redirectToGitHubLogin(provider, redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FakeTwitterLoginControllerApi - axios parameter creator
 * @export
 */
export const FakeTwitterLoginControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLoginWithTwitter: async (redirectUri: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('doLoginWithTwitter', 'redirectUri', redirectUri)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('doLoginWithTwitter', 'state', state)
            const localVarPath = `/login/twitter/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToTwitterLogin: async (redirectUri: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('redirectToTwitterLogin', 'redirectUri', redirectUri)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('redirectToTwitterLogin', 'state', state)
            const localVarPath = `/login/twitter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FakeTwitterLoginControllerApi - functional programming interface
 * @export
 */
export const FakeTwitterLoginControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FakeTwitterLoginControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doLoginWithTwitter(redirectUri: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doLoginWithTwitter(redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FakeTwitterLoginControllerApi.doLoginWithTwitter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectToTwitterLogin(redirectUri: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectToTwitterLogin(redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FakeTwitterLoginControllerApi.redirectToTwitterLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FakeTwitterLoginControllerApi - factory interface
 * @export
 */
export const FakeTwitterLoginControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FakeTwitterLoginControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLoginWithTwitter(redirectUri: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.doLoginWithTwitter(redirectUri, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToTwitterLogin(redirectUri: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.redirectToTwitterLogin(redirectUri, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FakeTwitterLoginControllerApi - object-oriented interface
 * @export
 * @class FakeTwitterLoginControllerApi
 * @extends {BaseAPI}
 */
export class FakeTwitterLoginControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} redirectUri 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeTwitterLoginControllerApi
     */
    public doLoginWithTwitter(redirectUri: string, state: string, options?: RawAxiosRequestConfig) {
        return FakeTwitterLoginControllerApiFp(this.configuration).doLoginWithTwitter(redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUri 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeTwitterLoginControllerApi
     */
    public redirectToTwitterLogin(redirectUri: string, state: string, options?: RawAxiosRequestConfig) {
        return FakeTwitterLoginControllerApiFp(this.configuration).redirectToTwitterLogin(redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LikeControllerApi - axios parameter creator
 * @export
 */
export const LikeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/likes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countByPresentation: async (presentationId: Presentation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('countByPresentation', 'presentationId', presentationId)
            const localVarPath = `/presentations/{presentationId}/likes`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {Like} like 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVote: async (presentationId: Presentation, like: Like, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('createVote', 'presentationId', presentationId)
            // verify required parameter 'like' is not null or undefined
            assertParamExists('createVote', 'like', like)
            const localVarPath = `/presentations/{presentationId}/likes`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(like, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikes: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getLikes', 'token', token)
            const localVarPath = `/likes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikesSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/likes/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeControllerApi - functional programming interface
 * @export
 */
export const LikeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LikeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countByPresentation(presentationId: Presentation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countByPresentation(presentationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi.countByPresentation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {Like} like 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVote(presentationId: Presentation, like: Like, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVote(presentationId, like, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi.createVote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikes(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LikeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLikes(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi.getLikes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikesSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLikesSummary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi.getLikesSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LikeControllerApi - factory interface
 * @export
 */
export const LikeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LikeControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countByPresentation(presentationId: Presentation, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.countByPresentation(presentationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {Like} like 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVote(presentationId: Presentation, like: Like, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createVote(presentationId, like, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikes(token: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<LikeResponse>> {
            return localVarFp.getLikes(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikesSummary(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getLikesSummary(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LikeControllerApi - object-oriented interface
 * @export
 * @class LikeControllerApi
 * @extends {BaseAPI}
 */
export class LikeControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public _delete(id: string, options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Presentation} presentationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public countByPresentation(presentationId: Presentation, options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration).countByPresentation(presentationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Presentation} presentationId 
     * @param {Like} like 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public createVote(presentationId: Presentation, like: Like, options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration).createVote(presentationId, like, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public getLikes(token: string, options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration).getLikes(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public getLikesSummary(options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration).getLikesSummary(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MailControllerApi - axios parameter creator
 * @export
 */
export const MailControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mailing/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendMailsRequest} sendMailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMails: async (sendMailsRequest: SendMailsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMailsRequest' is not null or undefined
            assertParamExists('sendMails', 'sendMailsRequest', sendMailsRequest)
            const localVarPath = `/mailing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMailsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailControllerApi - functional programming interface
 * @export
 */
export const MailControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailControllerApi.getTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendMailsRequest} sendMailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMails(sendMailsRequest: SendMailsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMails(sendMailsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailControllerApi.sendMails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MailControllerApi - factory interface
 * @export
 */
export const MailControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendMailsRequest} sendMailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMails(sendMailsRequest: SendMailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendMails(sendMailsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MailControllerApi - object-oriented interface
 * @export
 * @class MailControllerApi
 * @extends {BaseAPI}
 */
export class MailControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailControllerApi
     */
    public getTemplates(options?: RawAxiosRequestConfig) {
        return MailControllerApiFp(this.configuration).getTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendMailsRequest} sendMailsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailControllerApi
     */
    public sendMails(sendMailsRequest: SendMailsRequest, options?: RawAxiosRequestConfig) {
        return MailControllerApiFp(this.configuration).sendMails(sendMailsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PageControllerApi - axios parameter creator
 * @export
 */
export const PageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {PageContent} pageContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPage: async (id: string, pageContent: PageContent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('createPage', 'id', id)
            // verify required parameter 'pageContent' is not null or undefined
            assertParamExists('createPage', 'pageContent', pageContent)
            const localVarPath = `/pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePage: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deletePage', 'id', id)
            const localVarPath = `/pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPage', 'id', id)
            const localVarPath = `/pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPages: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/pages`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {PageContent} pageContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePage: async (id: string, pageContent: PageContent, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('updatePage', 'id', id)
            // verify required parameter 'pageContent' is not null or undefined
            assertParamExists('updatePage', 'pageContent', pageContent)
            const localVarPath = `/pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(pageContent, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageControllerApi - functional programming interface
 * @export
 */
export const PageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {PageContent} pageContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createPage(id: string, pageContent: PageContent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createPage(id, pageContent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageControllerApi.createPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePage(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageControllerApi.deletePage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPage(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageControllerApi.getPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPages(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPages(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageControllerApi.getPages']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {PageContent} pageContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePage(id: string, pageContent: PageContent, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePage(id, pageContent, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageControllerApi.updatePage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PageControllerApi - factory interface
 * @export
 */
export const PageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {PageContent} pageContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createPage(id: string, pageContent: PageContent, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.createPage(id, pageContent, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePage(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getPage(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPages(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getPages(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {PageContent} pageContent 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePage(id: string, pageContent: PageContent, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updatePage(id, pageContent, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageControllerApi - object-oriented interface
 * @export
 * @class PageControllerApi
 * @extends {BaseAPI}
 */
export class PageControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {PageContent} pageContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public createPage(id: string, pageContent: PageContent, options?: RawAxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).createPage(id, pageContent, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public deletePage(id: string, options?: RawAxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).deletePage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public getPage(id: string, options?: RawAxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).getPage(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public getPages(options?: RawAxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).getPages(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {PageContent} pageContent 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public updatePage(id: string, pageContent: PageContent, options?: RawAxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).updatePage(id, pageContent, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PresentationControllerApi - axios parameter creator
 * @export
 */
export const PresentationControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} presentationId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCospeaker: async (presentationId: string, email: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('addCospeaker', 'presentationId', presentationId)
            // verify required parameter 'email' is not null or undefined
            assertParamExists('addCospeaker', 'email', email)
            const localVarPath = `/presentations/{presentationId}/cospeakers/{email}`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)))
                .replace(`{${"email"}}`, encodeURIComponent(String(email)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRating: async (presentationId: string, rateRequest: RateRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('addRating', 'presentationId', presentationId)
            // verify required parameter 'rateRequest' is not null or undefined
            assertParamExists('addRating', 'rateRequest', rateRequest)
            const localVarPath = `/presentations/{presentationId}/ratings`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPresentations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/presentations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCospeakers: async (presentationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('getCospeakers', 'presentationId', presentationId)
            const localVarPath = `/presentations/{presentationId}/cospeakers`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCospeaker: async (presentationId: string, id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('removeCospeaker', 'presentationId', presentationId)
            // verify required parameter 'id' is not null or undefined
            assertParamExists('removeCospeaker', 'id', id)
            const localVarPath = `/presentations/{presentationId}/cospeakers/{id}`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)))
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {string} ratingId 
         * @param {Rate} rate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRating: async (presentationId: string, ratingId: string, rate: Rate, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('updateRating', 'presentationId', presentationId)
            // verify required parameter 'ratingId' is not null or undefined
            assertParamExists('updateRating', 'ratingId', ratingId)
            // verify required parameter 'rate' is not null or undefined
            assertParamExists('updateRating', 'rate', rate)
            const localVarPath = `/presentations/{presentationId}/ratings/{ratingId}`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)))
                .replace(`{${"ratingId"}}`, encodeURIComponent(String(ratingId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'PUT', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(rate, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PresentationControllerApi - functional programming interface
 * @export
 */
export const PresentationControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PresentationControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} presentationId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addCospeaker(presentationId: string, email: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addCospeaker(presentationId, email, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresentationControllerApi.addCospeaker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addRating(presentationId: string, rateRequest: RateRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addRating(presentationId, rateRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresentationControllerApi.addRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllPresentations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FullPresentation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllPresentations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresentationControllerApi.getAllPresentations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllTags(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tag>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllTags(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresentationControllerApi.getAllTags']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCospeakers(presentationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Set<User>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCospeakers(presentationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresentationControllerApi.getCospeakers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async removeCospeaker(presentationId: string, id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.removeCospeaker(presentationId, id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresentationControllerApi.removeCospeaker']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {string} ratingId 
         * @param {Rate} rate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateRating(presentationId: string, ratingId: string, rate: Rate, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateRating(presentationId, ratingId, rate, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PresentationControllerApi.updateRating']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PresentationControllerApi - factory interface
 * @export
 */
export const PresentationControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PresentationControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} presentationId 
         * @param {string} email 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCospeaker(presentationId: string, email: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.addCospeaker(presentationId, email, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {RateRequest} rateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addRating(presentationId: string, rateRequest: RateRequest, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.addRating(presentationId, rateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllPresentations(options?: RawAxiosRequestConfig): AxiosPromise<Array<FullPresentation>> {
            return localVarFp.getAllPresentations(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllTags(options?: RawAxiosRequestConfig): AxiosPromise<Array<Tag>> {
            return localVarFp.getAllTags(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCospeakers(presentationId: string, options?: RawAxiosRequestConfig): AxiosPromise<Set<User>> {
            return localVarFp.getCospeakers(presentationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        removeCospeaker(presentationId: string, id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.removeCospeaker(presentationId, id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} presentationId 
         * @param {string} ratingId 
         * @param {Rate} rate 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateRating(presentationId: string, ratingId: string, rate: Rate, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.updateRating(presentationId, ratingId, rate, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PresentationControllerApi - object-oriented interface
 * @export
 * @class PresentationControllerApi
 * @extends {BaseAPI}
 */
export class PresentationControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} presentationId 
     * @param {string} email 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresentationControllerApi
     */
    public addCospeaker(presentationId: string, email: string, options?: RawAxiosRequestConfig) {
        return PresentationControllerApiFp(this.configuration).addCospeaker(presentationId, email, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} presentationId 
     * @param {RateRequest} rateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresentationControllerApi
     */
    public addRating(presentationId: string, rateRequest: RateRequest, options?: RawAxiosRequestConfig) {
        return PresentationControllerApiFp(this.configuration).addRating(presentationId, rateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresentationControllerApi
     */
    public getAllPresentations(options?: RawAxiosRequestConfig) {
        return PresentationControllerApiFp(this.configuration).getAllPresentations(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresentationControllerApi
     */
    public getAllTags(options?: RawAxiosRequestConfig) {
        return PresentationControllerApiFp(this.configuration).getAllTags(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} presentationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresentationControllerApi
     */
    public getCospeakers(presentationId: string, options?: RawAxiosRequestConfig) {
        return PresentationControllerApiFp(this.configuration).getCospeakers(presentationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} presentationId 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresentationControllerApi
     */
    public removeCospeaker(presentationId: string, id: string, options?: RawAxiosRequestConfig) {
        return PresentationControllerApiFp(this.configuration).removeCospeaker(presentationId, id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} presentationId 
     * @param {string} ratingId 
     * @param {Rate} rate 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PresentationControllerApi
     */
    public updateRating(presentationId: string, ratingId: string, rate: Rate, options?: RawAxiosRequestConfig) {
        return PresentationControllerApiFp(this.configuration).updateRating(presentationId, ratingId, rate, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceControllerApi - axios parameter creator
 * @export
 */
export const ResourceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Upload a Multipart file for the partner\'s logo
         * @summary Store partner logo
         * @param {string} id ID of the partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePartnerLogo: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storePartnerLogo', 'id', id)
            const localVarPath = `/resources/partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Upload a Multipart file for the speaker\'s photo
         * @summary Store speaker photo
         * @param {string} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeUserProfilePicture: async (userId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('storeUserProfilePicture', 'userId', userId)
            const localVarPath = `/resources/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceControllerApi - functional programming interface
 * @export
 */
export const ResourceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * Upload a Multipart file for the partner\'s logo
         * @summary Store partner logo
         * @param {string} id ID of the partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storePartnerLogo(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storePartnerLogo(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceControllerApi.storePartnerLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * Upload a Multipart file for the speaker\'s photo
         * @summary Store speaker photo
         * @param {string} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storeUserProfilePicture(userId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storeUserProfilePicture(userId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceControllerApi.storeUserProfilePicture']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceControllerApi - factory interface
 * @export
 */
export const ResourceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceControllerApiFp(configuration)
    return {
        /**
         * Upload a Multipart file for the partner\'s logo
         * @summary Store partner logo
         * @param {string} id ID of the partner
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePartnerLogo(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.storePartnerLogo(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Upload a Multipart file for the speaker\'s photo
         * @summary Store speaker photo
         * @param {string} userId ID of the user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storeUserProfilePicture(userId: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.storeUserProfilePicture(userId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceControllerApi - object-oriented interface
 * @export
 * @class ResourceControllerApi
 * @extends {BaseAPI}
 */
export class ResourceControllerApi extends BaseAPI {
    /**
     * Upload a Multipart file for the partner\'s logo
     * @summary Store partner logo
     * @param {string} id ID of the partner
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControllerApi
     */
    public storePartnerLogo(id: string, options?: RawAxiosRequestConfig) {
        return ResourceControllerApiFp(this.configuration).storePartnerLogo(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Upload a Multipart file for the speaker\'s photo
     * @summary Store speaker photo
     * @param {string} userId ID of the user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControllerApi
     */
    public storeUserProfilePicture(userId: string, options?: RawAxiosRequestConfig) {
        return ResourceControllerApiFp(this.configuration).storeUserProfilePicture(userId, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomControllerApi - axios parameter creator
 * @export
 */
export const RoomControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoom', 'id', id)
            const localVarPath = `/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoomById', 'id', id)
            const localVarPath = `/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Room} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoom: async (room: Room, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'room' is not null or undefined
            assertParamExists('saveRoom', 'room', room)
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(room, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomControllerApi - functional programming interface
 * @export
 */
export const RoomControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoom(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoom(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomControllerApi.deleteRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomControllerApi.getAllRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomControllerApi.getRoomById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Room} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRoom(room: Room, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRoom(room, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomControllerApi.saveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomControllerApi - factory interface
 * @export
 */
export const RoomControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRoom(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRooms(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.getRoomById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Room} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoom(room: Room, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.saveRoom(room, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomControllerApi - object-oriented interface
 * @export
 * @class RoomControllerApi
 * @extends {BaseAPI}
 */
export class RoomControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomControllerApi
     */
    public deleteRoom(id: string, options?: RawAxiosRequestConfig) {
        return RoomControllerApiFp(this.configuration).deleteRoom(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomControllerApi
     */
    public getAllRooms(options?: RawAxiosRequestConfig) {
        return RoomControllerApiFp(this.configuration).getAllRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomControllerApi
     */
    public getRoomById(id: string, options?: RawAxiosRequestConfig) {
        return RoomControllerApiFp(this.configuration).getRoomById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Room} room 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomControllerApi
     */
    public saveRoom(room: Room, options?: RawAxiosRequestConfig) {
        return RoomControllerApiFp(this.configuration).saveRoom(room, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TokenControllerApi - axios parameter creator
 * @export
 */
export const TokenControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/tokens/refresh-token`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TokenControllerApi - functional programming interface
 * @export
 */
export const TokenControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TokenControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async refreshToken(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.refreshToken(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TokenControllerApi.refreshToken']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TokenControllerApi - factory interface
 * @export
 */
export const TokenControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TokenControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        refreshToken(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.refreshToken(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TokenControllerApi - object-oriented interface
 * @export
 * @class TokenControllerApi
 * @extends {BaseAPI}
 */
export class TokenControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TokenControllerApi
     */
    public refreshToken(options?: RawAxiosRequestConfig) {
        return TokenControllerApiFp(this.configuration).refreshToken(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TweeterControllerApi - axios parameter creator
 * @export
 */
export const TweeterControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tweets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TweeterControllerApi - functional programming interface
 * @export
 */
export const TweeterControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TweeterControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tweet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TweeterControllerApi.getTweets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TweeterControllerApi - factory interface
 * @export
 */
export const TweeterControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TweeterControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweets(options?: RawAxiosRequestConfig): AxiosPromise<Array<Tweet>> {
            return localVarFp.getTweets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TweeterControllerApi - object-oriented interface
 * @export
 * @class TweeterControllerApi
 * @extends {BaseAPI}
 */
export class TweeterControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweeterControllerApi
     */
    public getTweets(options?: RawAxiosRequestConfig) {
        return TweeterControllerApiFp(this.configuration).getTweets(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserAdminControllerApi - axios parameter creator
 * @export
 */
export const UserAdminControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsAdmin: async (userId: string, isAdmin: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('markAsAdmin', 'userId', userId)
            // verify required parameter 'isAdmin' is not null or undefined
            assertParamExists('markAsAdmin', 'isAdmin', isAdmin)
            const localVarPath = `/users/{userId}/admin/{isAdmin}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"isAdmin"}}`, encodeURIComponent(String(isAdmin)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isVolunteer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsVolunteer: async (userId: string, isVolunteer: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('markAsVolunteer', 'userId', userId)
            // verify required parameter 'isVolunteer' is not null or undefined
            assertParamExists('markAsVolunteer', 'isVolunteer', isVolunteer)
            const localVarPath = `/users/{userId}/volunteer/{isVolunteer}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"isVolunteer"}}`, encodeURIComponent(String(isVolunteer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication bearerAuth required
            // http bearer authentication required
            await setBearerAuthToObject(localVarHeaderParameter, configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserAdminControllerApi - functional programming interface
 * @export
 */
export const UserAdminControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserAdminControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllUsers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FullUser>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllUsers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAdminControllerApi.getAllUsers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsAdmin(userId: string, isAdmin: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsAdmin(userId, isAdmin, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAdminControllerApi.markAsAdmin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isVolunteer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsVolunteer(userId: string, isVolunteer: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsVolunteer(userId, isVolunteer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserAdminControllerApi.markAsVolunteer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserAdminControllerApi - factory interface
 * @export
 */
export const UserAdminControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserAdminControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllUsers(options?: RawAxiosRequestConfig): AxiosPromise<Array<FullUser>> {
            return localVarFp.getAllUsers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isAdmin 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsAdmin(userId: string, isAdmin: boolean, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.markAsAdmin(userId, isAdmin, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isVolunteer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsVolunteer(userId: string, isVolunteer: boolean, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.markAsVolunteer(userId, isVolunteer, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserAdminControllerApi - object-oriented interface
 * @export
 * @class UserAdminControllerApi
 * @extends {BaseAPI}
 */
export class UserAdminControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAdminControllerApi
     */
    public getAllUsers(options?: RawAxiosRequestConfig) {
        return UserAdminControllerApiFp(this.configuration).getAllUsers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {boolean} isAdmin 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAdminControllerApi
     */
    public markAsAdmin(userId: string, isAdmin: boolean, options?: RawAxiosRequestConfig) {
        return UserAdminControllerApiFp(this.configuration).markAsAdmin(userId, isAdmin, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {boolean} isVolunteer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserAdminControllerApi
     */
    public markAsVolunteer(userId: string, isVolunteer: boolean, options?: RawAxiosRequestConfig) {
        return UserAdminControllerApiFp(this.configuration).markAsVolunteer(userId, isVolunteer, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {PresentationRequest} presentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPresentationToUser: async (userId: string, presentationRequest: PresentationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addPresentationToUser', 'userId', userId)
            // verify required parameter 'presentationRequest' is not null or undefined
            assertParamExists('addPresentationToUser', 'presentationRequest', presentationRequest)
            const localVarPath = `/users/{userId}/presentations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(presentationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {WorkshopRequest} workshopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkshopToUser: async (userId: string, workshopRequest: WorkshopRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addWorkshopToUser', 'userId', userId)
            // verify required parameter 'workshopRequest' is not null or undefined
            assertParamExists('addWorkshopToUser', 'workshopRequest', workshopRequest)
            const localVarPath = `/users/{userId}/workshops`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workshopRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ParticipationData} participationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignParticipationData: async (userId: string, participationData: ParticipationData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignParticipationData', 'userId', userId)
            // verify required parameter 'participationData' is not null or undefined
            assertParamExists('assignParticipationData', 'participationData', participationData)
            const localVarPath = `/users/{userId}/participationData`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(participationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePresentation: async (userId: string, presentationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deletePresentation', 'userId', userId)
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('deletePresentation', 'presentationId', presentationId)
            const localVarPath = `/users/{userId}/presentations/{presentationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} workshopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkshop: async (userId: string, workshopId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('deleteWorkshop', 'userId', userId)
            // verify required parameter 'workshopId' is not null or undefined
            assertParamExists('deleteWorkshop', 'workshopId', workshopId)
            const localVarPath = `/users/{userId}/workshops/{workshopId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"workshopId"}}`, encodeURIComponent(String(workshopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdmins: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresentation: async (id: string, presentationId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPresentation', 'id', id)
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('getPresentation', 'presentationId', presentationId)
            const localVarPath = `/users/{id}/presentations/{presentationId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublicById', 'id', id)
            const localVarPath = `/users/{id}/public`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpeakers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/speakers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPresentations: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserPresentations', 'id', id)
            const localVarPath = `/users/{id}/presentations`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorkshops: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getUserWorkshops', 'id', id)
            const localVarPath = `/users/{id}/workshops`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/volunteers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {string} workshopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkshop: async (id: string, workshopId: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getWorkshop', 'id', id)
            // verify required parameter 'workshopId' is not null or undefined
            assertParamExists('getWorkshop', 'workshopId', workshopId)
            const localVarPath = `/users/{id}/workshops/{workshopId}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"workshopId"}}`, encodeURIComponent(String(workshopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save1: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('save1', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} presentationId 
         * @param {PresentationRequest} presentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePresentation: async (userId: string, presentationId: string, presentationRequest: PresentationRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updatePresentation', 'userId', userId)
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('updatePresentation', 'presentationId', presentationId)
            // verify required parameter 'presentationRequest' is not null or undefined
            assertParamExists('updatePresentation', 'presentationRequest', presentationRequest)
            const localVarPath = `/users/{userId}/presentations/{presentationId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(presentationRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} workshopId 
         * @param {WorkshopRequest} workshopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkshop: async (userId: string, workshopId: string, workshopRequest: WorkshopRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('updateWorkshop', 'userId', userId)
            // verify required parameter 'workshopId' is not null or undefined
            assertParamExists('updateWorkshop', 'workshopId', workshopId)
            // verify required parameter 'workshopRequest' is not null or undefined
            assertParamExists('updateWorkshop', 'workshopRequest', workshopRequest)
            const localVarPath = `/users/{userId}/workshops/{workshopId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"workshopId"}}`, encodeURIComponent(String(workshopId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(workshopRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {PresentationRequest} presentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPresentationToUser(userId: string, presentationRequest: PresentationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlinePresentation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPresentationToUser(userId, presentationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.addPresentationToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {WorkshopRequest} workshopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addWorkshopToUser(userId: string, workshopRequest: WorkshopRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineWorkshop>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addWorkshopToUser(userId, workshopRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.addWorkshopToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {ParticipationData} participationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignParticipationData(userId: string, participationData: ParticipationData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignParticipationData(userId, participationData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.assignParticipationData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deletePresentation(userId: string, presentationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deletePresentation(userId, presentationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.deletePresentation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} workshopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteWorkshop(userId: string, workshopId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteWorkshop(userId, workshopId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.deleteWorkshop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdmins(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdmins(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getAdmins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPresentation(id: string, presentationId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlinePresentation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPresentation(id, presentationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getPresentation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getPublicById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpeakers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpeakers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getSpeakers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserPresentations(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlinePresentation>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserPresentations(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getUserPresentations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUserWorkshops(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineWorkshop>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUserWorkshops(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getUserWorkshops']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolunteers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolunteers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getVolunteers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {string} workshopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getWorkshop(id: string, workshopId: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineWorkshop>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getWorkshop(id, workshopId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getWorkshop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save1(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save1(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.save1']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} presentationId 
         * @param {PresentationRequest} presentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updatePresentation(userId: string, presentationId: string, presentationRequest: PresentationRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlinePresentation>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updatePresentation(userId, presentationId, presentationRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updatePresentation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} workshopId 
         * @param {WorkshopRequest} workshopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async updateWorkshop(userId: string, workshopId: string, workshopRequest: WorkshopRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineWorkshop>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.updateWorkshop(userId, workshopId, workshopRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.updateWorkshop']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {PresentationRequest} presentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPresentationToUser(userId: string, presentationRequest: PresentationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InlinePresentation> {
            return localVarFp.addPresentationToUser(userId, presentationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {WorkshopRequest} workshopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWorkshopToUser(userId: string, workshopRequest: WorkshopRequest, options?: RawAxiosRequestConfig): AxiosPromise<InlineWorkshop> {
            return localVarFp.addWorkshopToUser(userId, workshopRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {ParticipationData} participationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignParticipationData(userId: string, participationData: ParticipationData, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.assignParticipationData(userId, participationData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePresentation(userId: string, presentationId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deletePresentation(userId, presentationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} workshopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteWorkshop(userId: string, workshopId: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteWorkshop(userId, workshopId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdmins(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAdmins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPresentation(id: string, presentationId: string, options?: RawAxiosRequestConfig): AxiosPromise<InlinePresentation> {
            return localVarFp.getPresentation(id, presentationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPublicById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpeakers(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getSpeakers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserPresentations(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<InlinePresentation>> {
            return localVarFp.getUserPresentations(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUserWorkshops(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<InlineWorkshop>> {
            return localVarFp.getUserWorkshops(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteers(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getVolunteers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {string} workshopId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getWorkshop(id: string, workshopId: string, options?: RawAxiosRequestConfig): AxiosPromise<InlineWorkshop> {
            return localVarFp.getWorkshop(id, workshopId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save1(user: User, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.save1(user, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} presentationId 
         * @param {PresentationRequest} presentationRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePresentation(userId: string, presentationId: string, presentationRequest: PresentationRequest, options?: RawAxiosRequestConfig): AxiosPromise<InlinePresentation> {
            return localVarFp.updatePresentation(userId, presentationId, presentationRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {string} workshopId 
         * @param {WorkshopRequest} workshopRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateWorkshop(userId: string, workshopId: string, workshopRequest: WorkshopRequest, options?: RawAxiosRequestConfig): AxiosPromise<InlineWorkshop> {
            return localVarFp.updateWorkshop(userId, workshopId, workshopRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {PresentationRequest} presentationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public addPresentationToUser(userId: string, presentationRequest: PresentationRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).addPresentationToUser(userId, presentationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {WorkshopRequest} workshopRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public addWorkshopToUser(userId: string, workshopRequest: WorkshopRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).addWorkshopToUser(userId, workshopRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {ParticipationData} participationData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public assignParticipationData(userId: string, participationData: ParticipationData, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).assignParticipationData(userId, participationData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} presentationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deletePresentation(userId: string, presentationId: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).deletePresentation(userId, presentationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} workshopId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public deleteWorkshop(userId: string, workshopId: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).deleteWorkshop(userId, workshopId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getAdmins(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getAdmins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getById(id: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} presentationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getPresentation(id: string, presentationId: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getPresentation(id, presentationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getPublicById(id: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getPublicById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getSpeakers(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getSpeakers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserPresentations(id: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUserPresentations(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getUserWorkshops(id: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getUserWorkshops(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getVolunteers(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getVolunteers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {string} workshopId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getWorkshop(id: string, workshopId: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getWorkshop(id, workshopId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public save1(user: User, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).save1(user, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} presentationId 
     * @param {PresentationRequest} presentationRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updatePresentation(userId: string, presentationId: string, presentationRequest: PresentationRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updatePresentation(userId, presentationId, presentationRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {string} workshopId 
     * @param {WorkshopRequest} workshopRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public updateWorkshop(userId: string, workshopId: string, workshopRequest: WorkshopRequest, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).updateWorkshop(userId, workshopId, workshopRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoteControllerApi - axios parameter creator
 * @export
 */
export const VoteControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {VoteRequest} voteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save: async (voteRequest: VoteRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'voteRequest' is not null or undefined
            assertParamExists('save', 'voteRequest', voteRequest)
            const localVarPath = `/votes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(voteRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('start', 'token', token)
            const localVarPath = `/votes/start/{token}`
                .replace(`{${"token"}}`, encodeURIComponent(String(token)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statistics: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/votes/statistics`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoteControllerApi - functional programming interface
 * @export
 */
export const VoteControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoteControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {VoteRequest} voteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save(voteRequest: VoteRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineVote>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save(voteRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoteControllerApi.save']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async start(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<InlineVote>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.start(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoteControllerApi.start']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async statistics(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PresentationStats>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.statistics(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoteControllerApi.statistics']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoteControllerApi - factory interface
 * @export
 */
export const VoteControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoteControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {VoteRequest} voteRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save(voteRequest: VoteRequest, options?: RawAxiosRequestConfig): AxiosPromise<InlineVote> {
            return localVarFp.save(voteRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        start(token: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<InlineVote>> {
            return localVarFp.start(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        statistics(options?: RawAxiosRequestConfig): AxiosPromise<Array<PresentationStats>> {
            return localVarFp.statistics(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoteControllerApi - object-oriented interface
 * @export
 * @class VoteControllerApi
 * @extends {BaseAPI}
 */
export class VoteControllerApi extends BaseAPI {
    /**
     * 
     * @param {VoteRequest} voteRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteControllerApi
     */
    public save(voteRequest: VoteRequest, options?: RawAxiosRequestConfig) {
        return VoteControllerApiFp(this.configuration).save(voteRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteControllerApi
     */
    public start(token: string, options?: RawAxiosRequestConfig) {
        return VoteControllerApiFp(this.configuration).start(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoteControllerApi
     */
    public statistics(options?: RawAxiosRequestConfig) {
        return VoteControllerApiFp(this.configuration).statistics(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoucherControllerApi - axios parameter creator
 * @export
 */
export const VoucherControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canUseVoucher: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('canUseVoucher', 'id', id)
            const localVarPath = `/vouchers/{id}/check`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenerateVouchersRequest} generateVouchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVoucher: async (generateVouchersRequest: GenerateVouchersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateVouchersRequest' is not null or undefined
            assertParamExists('createVoucher', 'generateVouchersRequest', generateVouchersRequest)
            const localVarPath = `/vouchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateVouchersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vouchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVoucher: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendVoucher', 'id', id)
            const localVarPath = `/vouchers/{id}/re-send`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVouchers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vouchers/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoucherControllerApi - functional programming interface
 * @export
 */
export const VoucherControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoucherControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canUseVoucher(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistrationError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canUseVoucher(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.canUseVoucher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GenerateVouchersRequest} generateVouchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVoucher(generateVouchersRequest: GenerateVouchersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Voucher>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVoucher(generateVouchersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.createVoucher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Voucher>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.findAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendVoucher(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendVoucher(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.resendVoucher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendVouchers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendVouchers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.sendVouchers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoucherControllerApi - factory interface
 * @export
 */
export const VoucherControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoucherControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canUseVoucher(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RegistrationError> {
            return localVarFp.canUseVoucher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenerateVouchersRequest} generateVouchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVoucher(generateVouchersRequest: GenerateVouchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Voucher>> {
            return localVarFp.createVoucher(generateVouchersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<Voucher>> {
            return localVarFp.findAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVoucher(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendVoucher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVouchers(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendVouchers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoucherControllerApi - object-oriented interface
 * @export
 * @class VoucherControllerApi
 * @extends {BaseAPI}
 */
export class VoucherControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public canUseVoucher(id: string, options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).canUseVoucher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenerateVouchersRequest} generateVouchersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public createVoucher(generateVouchersRequest: GenerateVouchersRequest, options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).createVoucher(generateVouchersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public findAll(options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).findAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public resendVoucher(id: string, options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).resendVoucher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public sendVouchers(options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).sendVouchers(options).then((request) => request(this.axios, this.basePath));
    }
}



