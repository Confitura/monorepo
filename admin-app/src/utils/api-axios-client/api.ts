/* tslint:disable */
/* eslint-disable */
/**
 * Jelatyna API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import type { Configuration } from './configuration';
import type { AxiosPromise, AxiosInstance, RawAxiosRequestConfig } from 'axios';
import globalAxios from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
import type { RequestArgs } from './base';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, BaseAPI, RequiredError, operationServerMap } from './base';

/**
 * 
 * @export
 * @interface AgendaEntry
 */
export interface AgendaEntry {
    /**
     * 
     * @type {string}
     * @memberof AgendaEntry
     */
    'id'?: string;
    /**
     * 
     * @type {TimeSlot}
     * @memberof AgendaEntry
     */
    'timeSlot': TimeSlot;
    /**
     * 
     * @type {Room}
     * @memberof AgendaEntry
     */
    'room'?: Room;
    /**
     * 
     * @type {string}
     * @memberof AgendaEntry
     */
    'label'?: string;
    /**
     * 
     * @type {Presentation}
     * @memberof AgendaEntry
     */
    'presentation'?: Presentation;
    /**
     * 
     * @type {Set<PublicUser>}
     * @memberof AgendaEntry
     */
    'speakers'?: Set<PublicUser>;
    /**
     * 
     * @type {number}
     * @memberof AgendaEntry
     */
    'timeSlotOrder'?: number;
}
/**
 * 
 * @export
 * @interface AllegroContext
 */
export interface AllegroContext {
    /**
     * 
     * @type {string}
     * @memberof AllegroContext
     */
    'auctionId'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllegroContext
     */
    'auctionName'?: string;
    /**
     * 
     * @type {string}
     * @memberof AllegroContext
     */
    'buyerLogin'?: string;
}
/**
 * 
 * @export
 * @interface GenerateVouchersRequest
 */
export interface GenerateVouchersRequest {
    /**
     * 
     * @type {string}
     * @memberof GenerateVouchersRequest
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof GenerateVouchersRequest
     */
    'comment'?: string;
    /**
     * 
     * @type {number}
     * @memberof GenerateVouchersRequest
     */
    'sponsorVouchers'?: number;
    /**
     * 
     * @type {number}
     * @memberof GenerateVouchersRequest
     */
    'participantVouchers'?: number;
}
/**
 * 
 * @export
 * @interface Like
 */
export interface Like {
    /**
     * 
     * @type {string}
     * @memberof Like
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Like
     */
    'token': string;
    /**
     * 
     * @type {Presentation}
     * @memberof Like
     */
    'presentation'?: Presentation;
}
/**
 * 
 * @export
 * @interface LikeResponse
 */
export interface LikeResponse {
    /**
     * 
     * @type {string}
     * @memberof LikeResponse
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof LikeResponse
     */
    'presentationId'?: string;
}
/**
 * 
 * @export
 * @interface LocalTime
 */
export interface LocalTime {
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'hour'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'minute'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'second'?: number;
    /**
     * 
     * @type {number}
     * @memberof LocalTime
     */
    'nano'?: number;
}
/**
 * 
 * @export
 * @interface MessageInfo
 */
export interface MessageInfo {
    /**
     * 
     * @type {string}
     * @memberof MessageInfo
     */
    'email'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof MessageInfo
     */
    'ticket'?: Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof MessageInfo
     */
    'variables'?: { [key: string]: string; };
    /**
     * 
     * @type {MessageInfo}
     * @memberof MessageInfo
     */
    'name'?: MessageInfo;
    /**
     * 
     * @type {MessageInfo}
     * @memberof MessageInfo
     */
    'token'?: MessageInfo;
}
/**
 * 
 * @export
 * @interface ParticipationData
 */
export interface ParticipationData {
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'id'?: string;
    /**
     * 
     * @type {Voucher}
     * @memberof ParticipationData
     */
    'voucher'?: Voucher;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'lastName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'firstName'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'email'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ParticipationData
     */
    'privacyPolicyAccepted'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'gender'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'size'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'info'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'arrivalDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'registrationDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'registeredBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'ticketSendDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'surveySendDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof ParticipationData
     */
    'fullName'?: string;
}
/**
 * 
 * @export
 * @interface Presentation
 */
export interface Presentation {
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'shortDescription': string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'description': string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'level': string;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'language': string;
    /**
     * 
     * @type {Set<Tag>}
     * @memberof Presentation
     */
    'tags'?: Set<Tag>;
    /**
     * 
     * @type {Set<User>}
     * @memberof Presentation
     */
    'speakers': Set<User>;
    /**
     * 
     * @type {Set<Rate>}
     * @memberof Presentation
     */
    'ratings'?: Set<Rate>;
    /**
     * 
     * @type {string}
     * @memberof Presentation
     */
    'status'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof Presentation
     */
    'workshop'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof Presentation
     */
    'accepted'?: boolean;
    /**
     * 
     * @type {Presentation}
     * @memberof Presentation
     */
    'speaker'?: Presentation;
    /**
     * 
     * @type {boolean}
     * @memberof Presentation
     */
    'new'?: boolean;
}
/**
 * 
 * @export
 * @interface PublicUser
 */
export interface PublicUser {
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'github'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'www'?: string;
    /**
     * 
     * @type {string}
     * @memberof PublicUser
     */
    'photo'?: string;
}
/**
 * 
 * @export
 * @interface Rate
 */
export interface Rate {
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'value'?: RateValueEnum;
    /**
     * 
     * @type {string}
     * @memberof Rate
     */
    'comment'?: string;
    /**
     * 
     * @type {Presentation}
     * @memberof Rate
     */
    'presentation'?: Presentation;
}

export const RateValueEnum = {
    Awesome: 'AWESOME',
    Great: 'GREAT',
    ItWasFine: 'IT_WAS_FINE',
    Bad: 'BAD',
    Terrible: 'TERRIBLE'
} as const;

export type RateValueEnum = typeof RateValueEnum[keyof typeof RateValueEnum];

/**
 * 
 * @export
 * @interface RegistrationError
 */
export interface RegistrationError {
    /**
     * 
     * @type {string}
     * @memberof RegistrationError
     */
    'reason'?: string;
    /**
     * 
     * @type {string}
     * @memberof RegistrationError
     */
    'additionalInfo'?: string;
}
/**
 * 
 * @export
 * @interface Room
 */
export interface Room {
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Room
     */
    'label'?: string;
    /**
     * 
     * @type {number}
     * @memberof Room
     */
    'displayOrder': number;
}
/**
 * 
 * @export
 * @interface SendMailsRequest
 */
export interface SendMailsRequest {
    /**
     * 
     * @type {string}
     * @memberof SendMailsRequest
     */
    'template'?: string;
    /**
     * 
     * @type {Array<MessageInfo>}
     * @memberof SendMailsRequest
     */
    'messageInfoList'?: Array<MessageInfo>;
}
/**
 * 
 * @export
 * @interface StoreRequest
 */
export interface StoreRequest {
    /**
     * 
     * @type {File}
     * @memberof StoreRequest
     */
    'file': File;
}
/**
 * 
 * @export
 * @interface Tag
 */
export interface Tag {
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tag
     */
    'name'?: string;
}
/**
 * 
 * @export
 * @interface TimeSlot
 */
export interface TimeSlot {
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof TimeSlot
     */
    'label'?: string;
    /**
     * 
     * @type {LocalTime}
     * @memberof TimeSlot
     */
    'start'?: LocalTime;
    /**
     * 
     * @type {LocalTime}
     * @memberof TimeSlot
     */
    'end'?: LocalTime;
    /**
     * 
     * @type {boolean}
     * @memberof TimeSlot
     */
    'forAllRooms'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof TimeSlot
     */
    'displayOrder': number;
}
/**
 * 
 * @export
 * @interface Tweet
 */
export interface Tweet {
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'twitterHandle'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'avatar'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'text'?: string;
    /**
     * 
     * @type {string}
     * @memberof Tweet
     */
    'time'?: string;
}
/**
 * 
 * @export
 * @interface User
 */
export interface User {
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'origin'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'name'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'email'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'bio'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'username'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'twitter'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'github'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'www'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'photo'?: string;
    /**
     * 
     * @type {string}
     * @memberof User
     */
    'socialId'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'privacyPolicyAccepted'?: boolean;
    /**
     * 
     * @type {Set<AgendaEntry>}
     * @memberof User
     */
    'personalAgenda'?: Set<AgendaEntry>;
    /**
     * 
     * @type {ParticipationData}
     * @memberof User
     */
    'participationData'?: ParticipationData;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'admin'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'volunteer'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'speaker'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof User
     */
    'participant'?: boolean;
}
/**
 * 
 * @export
 * @interface Voucher
 */
export interface Voucher {
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'createdBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'createdDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'lastModifiedBy'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'lastModifiedDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'id'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'originalBuyer'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'comment'?: string;
    /**
     * 
     * @type {AllegroContext}
     * @memberof Voucher
     */
    'allegro'?: AllegroContext;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'ticketSendDate'?: string;
    /**
     * 
     * @type {string}
     * @memberof Voucher
     */
    'type'?: VoucherTypeEnum;
    /**
     * 
     * @type {boolean}
     * @memberof Voucher
     */
    'emailSent'?: boolean;
}

export const VoucherTypeEnum = {
    Participant: 'PARTICIPANT',
    Speaker: 'SPEAKER',
    Sponsor: 'SPONSOR'
} as const;

export type VoucherTypeEnum = typeof VoucherTypeEnum[keyof typeof VoucherTypeEnum];


/**
 * AllegroImportControllerApi - axios parameter creator
 * @export
 */
export const AllegroImportControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allegro/authorize`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback: async (code: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'code' is not null or undefined
            assertParamExists('callback', 'code', code)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('callback', 'state', state)
            const localVarPath = `/allegro/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (code !== undefined) {
                localVarQueryParameter['code'] = code;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doImport: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allegro/import`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allegro/status`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFromAllegro: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/allegro/report/ready-to-send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AllegroImportControllerApi - functional programming interface
 * @export
 */
export const AllegroImportControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = AllegroImportControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async authorize(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.authorize(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.authorize']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async callback(code: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.callback(code, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.callback']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doImport(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doImport(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.doImport']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getStatus(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: object; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getStatus(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.getStatus']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async importFromAllegro(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.importFromAllegro(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['AllegroImportControllerApi.importFromAllegro']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * AllegroImportControllerApi - factory interface
 * @export
 */
export const AllegroImportControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = AllegroImportControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        authorize(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.authorize(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} code 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        callback(code: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.callback(code, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doImport(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.doImport(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStatus(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: object; }> {
            return localVarFp.getStatus(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        importFromAllegro(options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.importFromAllegro(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * AllegroImportControllerApi - object-oriented interface
 * @export
 * @class AllegroImportControllerApi
 * @extends {BaseAPI}
 */
export class AllegroImportControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public authorize(options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).authorize(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} code 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public callback(code: string, state: string, options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).callback(code, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public doImport(options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).doImport(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public getStatus(options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).getStatus(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AllegroImportControllerApi
     */
    public importFromAllegro(options?: RawAxiosRequestConfig) {
        return AllegroImportControllerApiFp(this.configuration).importFromAllegro(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * DashboardControllerApi - axios parameter creator
 * @export
 */
export const DashboardControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrivals: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/arrivals`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMealStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/meal`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/registration`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTShirtSizes: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/tshirts`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherStats: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/vouchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrations: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/dashboard/registrations`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DashboardControllerApi - functional programming interface
 * @export
 */
export const DashboardControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = DashboardControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async arrivals(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.arrivals(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.arrivals']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMealStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMealStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.getMealStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRegistrationStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRegistrationStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.getRegistrationStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTShirtSizes(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTShirtSizes(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.getTShirtSizes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVoucherStats(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVoucherStats(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.getVoucherStats']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async registrations(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.registrations(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['DashboardControllerApi.registrations']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * DashboardControllerApi - factory interface
 * @export
 */
export const DashboardControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DashboardControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        arrivals(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.arrivals(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMealStats(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getMealStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRegistrationStats(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getRegistrationStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTShirtSizes(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getTShirtSizes(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherStats(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getVoucherStats(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        registrations(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.registrations(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DashboardControllerApi - object-oriented interface
 * @export
 * @class DashboardControllerApi
 * @extends {BaseAPI}
 */
export class DashboardControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public arrivals(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).arrivals(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getMealStats(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).getMealStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getRegistrationStats(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).getRegistrationStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getTShirtSizes(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).getTShirtSizes(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public getVoucherStats(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).getVoucherStats(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DashboardControllerApi
     */
    public registrations(options?: RawAxiosRequestConfig) {
        return DashboardControllerApiFp(this.configuration).registrations(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FakeOAuth2LoginControllerApi - axios parameter creator
 * @export
 */
export const FakeOAuth2LoginControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLoginWithGitHub: async (provider: string, redirectUri: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('doLoginWithGitHub', 'provider', provider)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('doLoginWithGitHub', 'redirectUri', redirectUri)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('doLoginWithGitHub', 'state', state)
            const localVarPath = `/login/{provider}/callback`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToGitHubLogin: async (provider: string, redirectUri: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'provider' is not null or undefined
            assertParamExists('redirectToGitHubLogin', 'provider', provider)
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('redirectToGitHubLogin', 'redirectUri', redirectUri)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('redirectToGitHubLogin', 'state', state)
            const localVarPath = `/login/{provider}`
                .replace(`{${"provider"}}`, encodeURIComponent(String(provider)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FakeOAuth2LoginControllerApi - functional programming interface
 * @export
 */
export const FakeOAuth2LoginControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FakeOAuth2LoginControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doLoginWithGitHub(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doLoginWithGitHub(provider, redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FakeOAuth2LoginControllerApi.doLoginWithGitHub']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectToGitHubLogin(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectToGitHubLogin(provider, redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FakeOAuth2LoginControllerApi.redirectToGitHubLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FakeOAuth2LoginControllerApi - factory interface
 * @export
 */
export const FakeOAuth2LoginControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FakeOAuth2LoginControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLoginWithGitHub(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.doLoginWithGitHub(provider, redirectUri, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} provider 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToGitHubLogin(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.redirectToGitHubLogin(provider, redirectUri, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FakeOAuth2LoginControllerApi - object-oriented interface
 * @export
 * @class FakeOAuth2LoginControllerApi
 * @extends {BaseAPI}
 */
export class FakeOAuth2LoginControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} provider 
     * @param {string} redirectUri 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeOAuth2LoginControllerApi
     */
    public doLoginWithGitHub(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig) {
        return FakeOAuth2LoginControllerApiFp(this.configuration).doLoginWithGitHub(provider, redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} provider 
     * @param {string} redirectUri 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeOAuth2LoginControllerApi
     */
    public redirectToGitHubLogin(provider: string, redirectUri: string, state: string, options?: RawAxiosRequestConfig) {
        return FakeOAuth2LoginControllerApiFp(this.configuration).redirectToGitHubLogin(provider, redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * FakeTwitterLoginControllerApi - axios parameter creator
 * @export
 */
export const FakeTwitterLoginControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLoginWithTwitter: async (redirectUri: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('doLoginWithTwitter', 'redirectUri', redirectUri)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('doLoginWithTwitter', 'state', state)
            const localVarPath = `/login/twitter/callback`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToTwitterLogin: async (redirectUri: string, state: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'redirectUri' is not null or undefined
            assertParamExists('redirectToTwitterLogin', 'redirectUri', redirectUri)
            // verify required parameter 'state' is not null or undefined
            assertParamExists('redirectToTwitterLogin', 'state', state)
            const localVarPath = `/login/twitter`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (redirectUri !== undefined) {
                localVarQueryParameter['redirect_uri'] = redirectUri;
            }

            if (state !== undefined) {
                localVarQueryParameter['state'] = state;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FakeTwitterLoginControllerApi - functional programming interface
 * @export
 */
export const FakeTwitterLoginControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FakeTwitterLoginControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async doLoginWithTwitter(redirectUri: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.doLoginWithTwitter(redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FakeTwitterLoginControllerApi.doLoginWithTwitter']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async redirectToTwitterLogin(redirectUri: string, state: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.redirectToTwitterLogin(redirectUri, state, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['FakeTwitterLoginControllerApi.redirectToTwitterLogin']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * FakeTwitterLoginControllerApi - factory interface
 * @export
 */
export const FakeTwitterLoginControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FakeTwitterLoginControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        doLoginWithTwitter(redirectUri: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.doLoginWithTwitter(redirectUri, state, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} redirectUri 
         * @param {string} state 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        redirectToTwitterLogin(redirectUri: string, state: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.redirectToTwitterLogin(redirectUri, state, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FakeTwitterLoginControllerApi - object-oriented interface
 * @export
 * @class FakeTwitterLoginControllerApi
 * @extends {BaseAPI}
 */
export class FakeTwitterLoginControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} redirectUri 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeTwitterLoginControllerApi
     */
    public doLoginWithTwitter(redirectUri: string, state: string, options?: RawAxiosRequestConfig) {
        return FakeTwitterLoginControllerApiFp(this.configuration).doLoginWithTwitter(redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} redirectUri 
     * @param {string} state 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FakeTwitterLoginControllerApi
     */
    public redirectToTwitterLogin(redirectUri: string, state: string, options?: RawAxiosRequestConfig) {
        return FakeTwitterLoginControllerApiFp(this.configuration).redirectToTwitterLogin(redirectUri, state, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * LikeControllerApi - axios parameter creator
 * @export
 */
export const LikeControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('_delete', 'id', id)
            const localVarPath = `/likes/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countByPresentation: async (presentationId: Presentation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('countByPresentation', 'presentationId', presentationId)
            const localVarPath = `/presentations/{presentationId}/likes`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {Like} like 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVote: async (presentationId: Presentation, like: Like, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'presentationId' is not null or undefined
            assertParamExists('createVote', 'presentationId', presentationId)
            // verify required parameter 'like' is not null or undefined
            assertParamExists('createVote', 'like', like)
            const localVarPath = `/presentations/{presentationId}/likes`
                .replace(`{${"presentationId"}}`, encodeURIComponent(String(presentationId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(like, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikes: async (token: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'token' is not null or undefined
            assertParamExists('getLikes', 'token', token)
            const localVarPath = `/likes`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (token !== undefined) {
                localVarQueryParameter['token'] = token;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikesSummary: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/likes/summary`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LikeControllerApi - functional programming interface
 * @export
 */
export const LikeControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = LikeControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async _delete(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator._delete(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi._delete']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async countByPresentation(presentationId: Presentation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<number>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.countByPresentation(presentationId, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi.countByPresentation']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {Like} like 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVote(presentationId: Presentation, like: Like, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVote(presentationId, like, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi.createVote']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikes(token: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<LikeResponse>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLikes(token, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi.getLikes']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getLikesSummary(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<{ [key: string]: number; }>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getLikesSummary(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['LikeControllerApi.getLikesSummary']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * LikeControllerApi - factory interface
 * @export
 */
export const LikeControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = LikeControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        _delete(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp._delete(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        countByPresentation(presentationId: Presentation, options?: RawAxiosRequestConfig): AxiosPromise<number> {
            return localVarFp.countByPresentation(presentationId, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Presentation} presentationId 
         * @param {Like} like 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVote(presentationId: Presentation, like: Like, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.createVote(presentationId, like, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} token 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikes(token: string, options?: RawAxiosRequestConfig): AxiosPromise<Array<LikeResponse>> {
            return localVarFp.getLikes(token, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLikesSummary(options?: RawAxiosRequestConfig): AxiosPromise<{ [key: string]: number; }> {
            return localVarFp.getLikesSummary(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * LikeControllerApi - object-oriented interface
 * @export
 * @class LikeControllerApi
 * @extends {BaseAPI}
 */
export class LikeControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public _delete(id: string, options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration)._delete(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Presentation} presentationId 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public countByPresentation(presentationId: Presentation, options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration).countByPresentation(presentationId, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Presentation} presentationId 
     * @param {Like} like 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public createVote(presentationId: Presentation, like: Like, options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration).createVote(presentationId, like, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} token 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public getLikes(token: string, options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration).getLikes(token, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LikeControllerApi
     */
    public getLikesSummary(options?: RawAxiosRequestConfig) {
        return LikeControllerApiFp(this.configuration).getLikesSummary(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * MailControllerApi - axios parameter creator
 * @export
 */
export const MailControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/mailing/templates`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {SendMailsRequest} sendMailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMails: async (sendMailsRequest: SendMailsRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'sendMailsRequest' is not null or undefined
            assertParamExists('sendMails', 'sendMailsRequest', sendMailsRequest)
            const localVarPath = `/mailing`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(sendMailsRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * MailControllerApi - functional programming interface
 * @export
 */
export const MailControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = MailControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTemplates(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTemplates(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailControllerApi.getTemplates']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {SendMailsRequest} sendMailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendMails(sendMailsRequest: SendMailsRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendMails(sendMailsRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['MailControllerApi.sendMails']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * MailControllerApi - factory interface
 * @export
 */
export const MailControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = MailControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTemplates(options?: RawAxiosRequestConfig): AxiosPromise<Array<string>> {
            return localVarFp.getTemplates(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {SendMailsRequest} sendMailsRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendMails(sendMailsRequest: SendMailsRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendMails(sendMailsRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * MailControllerApi - object-oriented interface
 * @export
 * @class MailControllerApi
 * @extends {BaseAPI}
 */
export class MailControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailControllerApi
     */
    public getTemplates(options?: RawAxiosRequestConfig) {
        return MailControllerApiFp(this.configuration).getTemplates(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {SendMailsRequest} sendMailsRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof MailControllerApi
     */
    public sendMails(sendMailsRequest: SendMailsRequest, options?: RawAxiosRequestConfig) {
        return MailControllerApiFp(this.configuration).sendMails(sendMailsRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * PageControllerApi - axios parameter creator
 * @export
 */
export const PageControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPage', 'id', id)
            const localVarPath = `/pages/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PageControllerApi - functional programming interface
 * @export
 */
export const PageControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = PageControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPage(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<string>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPage(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['PageControllerApi.getPage']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * PageControllerApi - factory interface
 * @export
 */
export const PageControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = PageControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPage(id: string, options?: RawAxiosRequestConfig): AxiosPromise<string> {
            return localVarFp.getPage(id, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * PageControllerApi - object-oriented interface
 * @export
 * @class PageControllerApi
 * @extends {BaseAPI}
 */
export class PageControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PageControllerApi
     */
    public getPage(id: string, options?: RawAxiosRequestConfig) {
        return PageControllerApiFp(this.configuration).getPage(id, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * ResourceControllerApi - axios parameter creator
 * @export
 */
export const ResourceControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {StoreRequest} [storeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        store: async (userId: string, storeRequest?: StoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('store', 'userId', userId)
            const localVarPath = `/resources/{userId}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {StoreRequest} [storeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePartnerLogo: async (id: string, storeRequest?: StoreRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('storePartnerLogo', 'id', id)
            const localVarPath = `/resources/partners/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(storeRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ResourceControllerApi - functional programming interface
 * @export
 */
export const ResourceControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ResourceControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {StoreRequest} [storeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async store(userId: string, storeRequest?: StoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.store(userId, storeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceControllerApi.store']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {StoreRequest} [storeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async storePartnerLogo(id: string, storeRequest?: StoreRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.storePartnerLogo(id, storeRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['ResourceControllerApi.storePartnerLogo']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * ResourceControllerApi - factory interface
 * @export
 */
export const ResourceControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ResourceControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {StoreRequest} [storeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        store(userId: string, storeRequest?: StoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.store(userId, storeRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {StoreRequest} [storeRequest] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        storePartnerLogo(id: string, storeRequest?: StoreRequest, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.storePartnerLogo(id, storeRequest, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ResourceControllerApi - object-oriented interface
 * @export
 * @class ResourceControllerApi
 * @extends {BaseAPI}
 */
export class ResourceControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {StoreRequest} [storeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControllerApi
     */
    public store(userId: string, storeRequest?: StoreRequest, options?: RawAxiosRequestConfig) {
        return ResourceControllerApiFp(this.configuration).store(userId, storeRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {StoreRequest} [storeRequest] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ResourceControllerApi
     */
    public storePartnerLogo(id: string, storeRequest?: StoreRequest, options?: RawAxiosRequestConfig) {
        return ResourceControllerApiFp(this.configuration).storePartnerLogo(id, storeRequest, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * RoomControllerApi - axios parameter creator
 * @export
 */
export const RoomControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('deleteRoom', 'id', id)
            const localVarPath = `/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'DELETE', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRooms: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRoomById', 'id', id)
            const localVarPath = `/rooms/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {Room} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoom: async (room: Room, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'room' is not null or undefined
            assertParamExists('saveRoom', 'room', room)
            const localVarPath = `/rooms`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(room, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * RoomControllerApi - functional programming interface
 * @export
 */
export const RoomControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = RoomControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async deleteRoom(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.deleteRoom(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomControllerApi.deleteRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAllRooms(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAllRooms(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomControllerApi.getAllRooms']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRoomById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRoomById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomControllerApi.getRoomById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {Room} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async saveRoom(room: Room, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Room>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.saveRoom(room, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['RoomControllerApi.saveRoom']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * RoomControllerApi - factory interface
 * @export
 */
export const RoomControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = RoomControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteRoom(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.deleteRoom(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAllRooms(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAllRooms(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRoomById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.getRoomById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {Room} room 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveRoom(room: Room, options?: RawAxiosRequestConfig): AxiosPromise<Room> {
            return localVarFp.saveRoom(room, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * RoomControllerApi - object-oriented interface
 * @export
 * @class RoomControllerApi
 * @extends {BaseAPI}
 */
export class RoomControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomControllerApi
     */
    public deleteRoom(id: string, options?: RawAxiosRequestConfig) {
        return RoomControllerApiFp(this.configuration).deleteRoom(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomControllerApi
     */
    public getAllRooms(options?: RawAxiosRequestConfig) {
        return RoomControllerApiFp(this.configuration).getAllRooms(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomControllerApi
     */
    public getRoomById(id: string, options?: RawAxiosRequestConfig) {
        return RoomControllerApiFp(this.configuration).getRoomById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {Room} room 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof RoomControllerApi
     */
    public saveRoom(room: Room, options?: RawAxiosRequestConfig) {
        return RoomControllerApiFp(this.configuration).saveRoom(room, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * TweeterControllerApi - axios parameter creator
 * @export
 */
export const TweeterControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweets: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/api/tweets`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TweeterControllerApi - functional programming interface
 * @export
 */
export const TweeterControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = TweeterControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getTweets(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Tweet>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getTweets(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['TweeterControllerApi.getTweets']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * TweeterControllerApi - factory interface
 * @export
 */
export const TweeterControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = TweeterControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTweets(options?: RawAxiosRequestConfig): AxiosPromise<Array<Tweet>> {
            return localVarFp.getTweets(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * TweeterControllerApi - object-oriented interface
 * @export
 * @class TweeterControllerApi
 * @extends {BaseAPI}
 */
export class TweeterControllerApi extends BaseAPI {
    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TweeterControllerApi
     */
    public getTweets(options?: RawAxiosRequestConfig) {
        return TweeterControllerApiFp(this.configuration).getTweets(options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * UserControllerApi - axios parameter creator
 * @export
 */
export const UserControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} userId 
         * @param {Presentation} presentation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPresentationToUser: async (userId: string, presentation: Presentation, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('addPresentationToUser', 'userId', userId)
            // verify required parameter 'presentation' is not null or undefined
            assertParamExists('addPresentationToUser', 'presentation', presentation)
            const localVarPath = `/users/{userId}/presentations`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(presentation, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {ParticipationData} participationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignParticipationData: async (userId: string, participationData: ParticipationData, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('assignParticipationData', 'userId', userId)
            // verify required parameter 'participationData' is not null or undefined
            assertParamExists('assignParticipationData', 'participationData', participationData)
            const localVarPath = `/users/{userId}/participationData`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(participationData, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdmins: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/admins`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getById', 'id', id)
            const localVarPath = `/users/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/current-user`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicById: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPublicById', 'id', id)
            const localVarPath = `/users/{id}/public`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpeakers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/speakers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/users/search/volunteers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isVolunteer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsVolunteer: async (userId: string, isVolunteer: boolean, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'userId' is not null or undefined
            assertParamExists('markAsVolunteer', 'userId', userId)
            // verify required parameter 'isVolunteer' is not null or undefined
            assertParamExists('markAsVolunteer', 'isVolunteer', isVolunteer)
            const localVarPath = `/users/{userId}/volunteer/{isVolunteer}`
                .replace(`{${"userId"}}`, encodeURIComponent(String(userId)))
                .replace(`{${"isVolunteer"}}`, encodeURIComponent(String(isVolunteer)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save: async (user: User, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'user' is not null or undefined
            assertParamExists('save', 'user', user)
            const localVarPath = `/users`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(user, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UserControllerApi - functional programming interface
 * @export
 */
export const UserControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = UserControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {Presentation} presentation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async addPresentationToUser(userId: string, presentation: Presentation, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.addPresentationToUser(userId, presentation, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.addPresentationToUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {ParticipationData} participationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async assignParticipationData(userId: string, participationData: ParticipationData, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.assignParticipationData(userId, participationData, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.assignParticipationData']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAdmins(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAdmins(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getAdmins']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCurrentUser(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<User>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCurrentUser(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getCurrentUser']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPublicById(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPublicById(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getPublicById']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSpeakers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSpeakers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getSpeakers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getVolunteers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getVolunteers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.getVolunteers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isVolunteer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async markAsVolunteer(userId: string, isVolunteer: boolean, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.markAsVolunteer(userId, isVolunteer, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.markAsVolunteer']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async save(user: User, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<object>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.save(user, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['UserControllerApi.save']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * UserControllerApi - factory interface
 * @export
 */
export const UserControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = UserControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} userId 
         * @param {Presentation} presentation 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPresentationToUser(userId: string, presentation: Presentation, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.addPresentationToUser(userId, presentation, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {ParticipationData} participationData 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assignParticipationData(userId: string, participationData: ParticipationData, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.assignParticipationData(userId, participationData, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAdmins(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getAdmins(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrentUser(options?: RawAxiosRequestConfig): AxiosPromise<User> {
            return localVarFp.getCurrentUser(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPublicById(id: string, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getPublicById(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSpeakers(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getSpeakers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVolunteers(options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.getVolunteers(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} userId 
         * @param {boolean} isVolunteer 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        markAsVolunteer(userId: string, isVolunteer: boolean, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.markAsVolunteer(userId, isVolunteer, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {User} user 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        save(user: User, options?: RawAxiosRequestConfig): AxiosPromise<object> {
            return localVarFp.save(user, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * UserControllerApi - object-oriented interface
 * @export
 * @class UserControllerApi
 * @extends {BaseAPI}
 */
export class UserControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} userId 
     * @param {Presentation} presentation 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public addPresentationToUser(userId: string, presentation: Presentation, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).addPresentationToUser(userId, presentation, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {ParticipationData} participationData 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public assignParticipationData(userId: string, participationData: ParticipationData, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).assignParticipationData(userId, participationData, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getAdmins(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getAdmins(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getById(id: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getCurrentUser(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getCurrentUser(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getPublicById(id: string, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getPublicById(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getSpeakers(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getSpeakers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public getVolunteers(options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).getVolunteers(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} userId 
     * @param {boolean} isVolunteer 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public markAsVolunteer(userId: string, isVolunteer: boolean, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).markAsVolunteer(userId, isVolunteer, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {User} user 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UserControllerApi
     */
    public save(user: User, options?: RawAxiosRequestConfig) {
        return UserControllerApiFp(this.configuration).save(user, options).then((request) => request(this.axios, this.basePath));
    }
}



/**
 * VoucherControllerApi - axios parameter creator
 * @export
 */
export const VoucherControllerApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canUseVoucher: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('canUseVoucher', 'id', id)
            const localVarPath = `/vouchers/{id}/check`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {GenerateVouchersRequest} generateVouchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVoucher: async (generateVouchersRequest: GenerateVouchersRequest, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'generateVouchersRequest' is not null or undefined
            assertParamExists('createVoucher', 'generateVouchersRequest', generateVouchersRequest)
            const localVarPath = `/vouchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};
            localVarRequestOptions.data = serializeDataIfNeeded(generateVouchersRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vouchers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVoucher: async (id: string, options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('resendVoucher', 'id', id)
            const localVarPath = `/vouchers/{id}/re-send`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVouchers: async (options: RawAxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/vouchers/send`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoucherControllerApi - functional programming interface
 * @export
 */
export const VoucherControllerApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = VoucherControllerApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async canUseVoucher(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RegistrationError>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.canUseVoucher(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.canUseVoucher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {GenerateVouchersRequest} generateVouchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async createVoucher(generateVouchersRequest: GenerateVouchersRequest, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Voucher>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.createVoucher(generateVouchersRequest, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.createVoucher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async findAll(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<Voucher>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.findAll(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.findAll']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async resendVoucher(id: string, options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.resendVoucher(id, options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.resendVoucher']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async sendVouchers(options?: RawAxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<void>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.sendVouchers(options);
            const localVarOperationServerIndex = configuration?.serverIndex ?? 0;
            const localVarOperationServerBasePath = operationServerMap['VoucherControllerApi.sendVouchers']?.[localVarOperationServerIndex]?.url;
            return (axios, basePath) => createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration)(axios, localVarOperationServerBasePath || basePath);
        },
    }
};

/**
 * VoucherControllerApi - factory interface
 * @export
 */
export const VoucherControllerApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = VoucherControllerApiFp(configuration)
    return {
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        canUseVoucher(id: string, options?: RawAxiosRequestConfig): AxiosPromise<RegistrationError> {
            return localVarFp.canUseVoucher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {GenerateVouchersRequest} generateVouchersRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createVoucher(generateVouchersRequest: GenerateVouchersRequest, options?: RawAxiosRequestConfig): AxiosPromise<Array<Voucher>> {
            return localVarFp.createVoucher(generateVouchersRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        findAll(options?: RawAxiosRequestConfig): AxiosPromise<Array<Voucher>> {
            return localVarFp.findAll(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {string} id 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        resendVoucher(id: string, options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.resendVoucher(id, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendVouchers(options?: RawAxiosRequestConfig): AxiosPromise<void> {
            return localVarFp.sendVouchers(options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * VoucherControllerApi - object-oriented interface
 * @export
 * @class VoucherControllerApi
 * @extends {BaseAPI}
 */
export class VoucherControllerApi extends BaseAPI {
    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public canUseVoucher(id: string, options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).canUseVoucher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {GenerateVouchersRequest} generateVouchersRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public createVoucher(generateVouchersRequest: GenerateVouchersRequest, options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).createVoucher(generateVouchersRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public findAll(options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).findAll(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {string} id 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public resendVoucher(id: string, options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).resendVoucher(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherControllerApi
     */
    public sendVouchers(options?: RawAxiosRequestConfig) {
        return VoucherControllerApiFp(this.configuration).sendVouchers(options).then((request) => request(this.axios, this.basePath));
    }
}



